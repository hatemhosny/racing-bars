import * as d3 from '../d3';

import type { Store } from '../store';
import { hideElement, showElement } from '../utils';
import { elements } from './elements';
import { buttons } from './buttons';
import type { RenderOptions } from './render-options';

/**
 * Renders the control buttons based on the current state of the store and render options.
 *
 * @param {Store} store - The store containing the current state and options.
 * @param {RenderOptions} renderOptions - The options for rendering.
 * @returns {void} - This function does not return a value; it modifies the DOM directly.
 */
export function renderControls(store: Store, renderOptions: RenderOptions) {
  const { marginTop, controlButtons } = store.getState().options;
  const { root, width, margin, barPadding } = renderOptions;

  const elementWidth = root.getBoundingClientRect().width;
  const controlButtonIcons = [
    { skipBack: buttons.skipBack },
    { play: buttons.play },
    { pause: buttons.pause },
    { skipForward: buttons.skipForward },
  ];

  d3.select(root)
    .append('div')
    .classed('controls', true)
    .style('position', 'absolute')
    .style('top', marginTop + 'px')
    .style('right', elementWidth - width + margin.right + barPadding + 'px')
    .selectAll('div')
    .data(controlButtonIcons)
    .enter()
    .append('div')
    .html((d) => Object.values(d)[0] as string)
    .attr('class', (d) => Object.keys(d)[0]);

  if (controlButtons === 'play') {
    hideElement(root, elements.skipBack);
    hideElement(root, elements.skipForward);
  }
  if (controlButtons === 'none') {
    hideElement(root, elements.controls);
  }
}

/**
 * Updates the visibility of control buttons based on the current state of the store.
 *
 * @param {Store} store - The store containing the current state and options.
 * @param {RenderOptions} renderOptions - The options for rendering.
 * @returns {void} - This function does not return a value; it modifies the DOM directly.
 */
export function updateControls(store: Store, renderOptions: RenderOptions) {
  const { overlays, loop } = store.getState().options;
  const { root } = renderOptions;

  if (store.getState().ticker.isRunning) {
    showElement(root, elements.pause);
    hideElement(root, elements.play);
  } else {
    showElement(root, elements.play);
    hideElement(root, elements.pause);
  }

  if (
    store.getState().ticker.isFirstDate &&
    (overlays === 'all' || overlays === 'play') &&
    !store.getState().ticker.isRunning
  ) {
    hideElement(root, elements.controls, true);
    showElement(root, elements.overlay);
    showElement(root, elements.overlayPlay);
    hideElement(root, elements.overlayRepeat);
  } else if (
    store.getState().ticker.isLastDate &&
    (overlays === 'all' || overlays === 'repeat') &&
    !(loop && store.getState().ticker.isRunning)
  ) {
    hideElement(root, elements.controls, true);
    showElement(root, elements.overlay);
    showElement(root, elements.overlayRepeat);
    hideElement(root, elements.overlayPlay);
  } else {
    showElement(root, elements.controls, true);
    hideElement(root, elements.overlay);
  }
}

/**
 * Renders the overlay buttons based on the current state of the store and render options.
 *
 * @param {Store} store - The store containing the current state and options.
 * @param {RenderOptions} renderOptions - The options for rendering.
 * @returns {void} - This function does not return a value; it modifies the DOM directly.
 */
export function renderOverlays(store: Store, renderOptions: RenderOptions) {
  const { minHeight, minWidth } = store.getState().options;
  const { root } = renderOptions;

  const overlayButtonIcons = [
    { overlayPlay: buttons.overlayPlay },
    { overlayRepeat: buttons.overlayRepeat },
  ];

  d3.select(root)
    .append('div')
    .classed('overlay', true)
    .style('min-height', minHeight + 'px')
    .style('min-width', minWidth + 'px')
    .selectAll('div')
    .data(overlayButtonIcons)
    .enter()
    .append('div')
    .html((d) => Object.values(d)[0] as string)
    .attr('class', (d) => Object.keys(d)[0]);
}
